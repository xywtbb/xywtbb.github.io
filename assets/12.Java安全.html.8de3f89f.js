import{_ as a,V as n,W as e,Z as s}from"./framework.0d0b2430.js";const t="/images/Web安全/Java安全&JWT.png",r={},o=s('<h1 id="java安全" tabindex="-1"><a class="header-anchor" href="#java安全" aria-hidden="true">#</a> Java安全</h1><p><img src="'+t+`" alt="Java安全&amp;JWT" loading="lazy"></p><h2 id="sql-injection-mitigation" tabindex="-1"><a class="header-anchor" href="#sql-injection-mitigation" aria-hidden="true">#</a> SQL Injection(mitigation)</h2><p>防御SQL注入，其实就是session，参数绑定，存储过程这样的注入<br> 利用session防御，session内容正常情况下是用户无法修改的<br><code>select * from users where user = &quot;&#39;&quot; + session getAttribute(&quot;userID&quot;) + &quot;&#39;&quot;;</code></p><h2 id="参数绑定方式-利用了sql的预编译技术" tabindex="-1"><a class="header-anchor" href="#参数绑定方式-利用了sql的预编译技术" aria-hidden="true">#</a> 参数绑定方式，利用了SQL的预编译技术</h2><p>使用预编译的preparedstatement的参数化查询可以组织大部分的SQL注入。<br> 使用PreparedStatement的参数化的查询可以阻止大部分的SQL注入。在使用参数化查询的情况下，数据库系统不会将参数的内容视为SQL指令的一部分来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有破坏性的指令，也不会被数据库所运行。因为对于参数化查询来说，查询SQL语句的格式是已经规定好了的，需要查的数据也设置好了，缺的只是具体的那几个数据而已。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>String query <span class="token operator">=</span> <span class="token string">&quot;SELECT * FROM users WHERE last_name = ?&quot;</span><span class="token punctuation">;</span>
PreparedStatement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span>prepareStatement<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>
statement<span class="token punctuation">.</span>setString<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> accountName<span class="token punctuation">)</span><span class="token punctuation">;</span>
ResultSet results <span class="token operator">=</span> statement<span class="token punctuation">.</span>executeQuery<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面说的方式也不是能够绝对的进行sql注入防御，只是减轻。<br> 如参数绑定方式可以使用下面方式绕过。<br> 通过使用case when语句可以将order by后的orderExpression表达式中添加select语句。</p><h2 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> JWT</h2><p>JSON web token（json 令牌）是一种跨域验证的方案。JWT不加密传输的数据，但是能够通过数字签名来验证数据未被篡改<br> JWT分为头部(header)，声明(claims)，签名(signature)，三个部分以英文句号隔开，JWT的内容进行了base64编码</p><p>一般采用SHA-256的base64加密<br> 1、服务端根据用户登录状态，将用户信息加密到token中，返给客户端 2、客户端收到服务端返回的token，存储在cookie中 3、客户端和服务端每次通信都带上token，可以放在http请求头信息中，如：Authorization字段里面 4、服务端解密token，验证内容，完成相应逻辑<br> 头部，声明，签名。可以修改头部和声明，加密修改为none，声明修改为true。<br> JWT进行破解，对令牌数据进行破解</p><h2 id="目录遍历访问控制xss等安全问题" tabindex="-1"><a class="header-anchor" href="#目录遍历访问控制xss等安全问题" aria-hidden="true">#</a> 目录遍历访问控制xss等安全问题</h2><p>文件上传配合目录遍历，覆盖文件自定义文件存储地址-基于用户名存储问题<br> 不安全登录状态 insecure login基于前端认证<br> 代码分析过关逻辑<br> 枚举用户参数对应数据库的其他数据信息<br> role，userid<br> 通过参数值构造URL获取用户更多的信息。<br> 核心：JAVA代码分析 === APK_APP分析<br> 模块引用（框架，自带），路由地址，静态文件（html，js），简易代码理解。</p>`,13),i=[o];function c(p,u){return n(),e("div",null,i)}const d=a(r,[["render",c],["__file","12.Java安全.html.vue"]]);export{d as default};
