import{_ as t,V as p,W as i,X as s,Y as e,$ as r,Z as n,y as l}from"./framework.0d0b2430.js";const o="/images/Web安全/CSRF攻击原理.png",c="/images/Web安全/脚本语言支持的协议.png",d={},h=n('<h1 id="csrf和ssrf" tabindex="-1"><a class="header-anchor" href="#csrf和ssrf" aria-hidden="true">#</a> CSRF和SSRF</h1><h2 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf" aria-hidden="true">#</a> CSRF</h2><p>**定义：**跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击。</p><p>**原理：**攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作。XSS 利用站点内的信任用户，盗取cookie；而CSRF通过伪装成受信任用户请求受信任的网站 利用目标用户的合法身份，以目标的名义执行某些非法参数。</p><p>利用条件：已经登录系统，用户访问URL 已存在的网站中让用户跳转。</p><p><img src="'+o+'" alt="CSRF攻击原理" width="200" height="300" loading="lazy"></p><p><strong>漏洞挖掘：</strong></p><ol><li>抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞</li><li>如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</li></ol><p><strong>防御：</strong></p><ol><li>验证 HTTP Referer字段。根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。</li><li>在请求地址中添加token并验证。</li><li>在HTTP头中自定义属性并验证：这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 CSRFToken 这个 HTTP 头属性，并把 token 值放入其中。同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，但是XMLHttpRequest请求通常用于Ajax方法中对于页面局部的异步刷新，并非所有请求都适合用这个类发起，所有局限性很大。</li><li>当用户发送重要的请求时需要输入原始密码；</li><li>设置验证码；</li><li>限制请求方式只能为POST。</li></ol><h2 id="ssrf-服务端请求伪造" tabindex="-1"><a class="header-anchor" href="#ssrf-服务端请求伪造" aria-hidden="true">#</a> SSRF（服务端请求伪造）</h2><p><strong>定义：</strong></p><p>是一种由攻击者伪造服务端的请求发起攻击。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。</p><p><strong>原理：</strong></p><p>大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p><p><strong>漏洞验证：</strong></p>',16),u={href:"http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E",target:"_blank",rel:"noopener noreferrer"},m=n(`<p>2.dnslog等工具进行测试，看是否被访问 --可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p><p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址 --从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址 --通过二级域名暴力猜解工具模糊猜测内网地址</p><p>4.直接返回的Banner、title、content等信息</p><p>5.留意bool型SSRF</p><p><strong>绕过：</strong></p><div class="language-url line-numbers-mode" data-ext="url"><pre class="language-url"><code><span class="token path">1.http:<span class="token path-separator">/</span><span class="token path-separator">/</span>baidu.com@www.baidu.com<span class="token path-separator">/</span></span>与http://www.baidu.com/请求时是相同的 

<span class="token path">2.</span>各种IP地址的进制转换 

<span class="token path">3.URL</span>跳转绕过：http://www.hackersb.cn/redirect.php<span class="token query"><span class="token query-delimiter">?</span><span class="token pair"><span class="token key">url</span>=<span class="token value">http://192.168.0.1/</span></span></span> 

<span class="token path">4.</span>短网址绕过 http://t.cn/RwbLKDx 

<span class="token path">5.xip.io</span>来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意） 指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务) 

<span class="token path">6.</span>限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi<span class="token query"><span class="token query-delimiter">?</span><span class="token pair"><span class="token key">url</span>=<span class="token value">http://10.42.7.78:80</span></span></span> 

<span class="token path">7.</span>探测内网域名，或者将自己的域名解析到内网ip 

<span class="token path">8.</span>例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host， 但这样可以用 http://abc@10.153.138.81/ 绕过
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>漏洞防御：</strong></p><p>1.禁止跳转;</p><p>2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准;</p><p>3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题;</p><p>4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）;</p><p>5.限制请求的端口为http常用的端口，比如 80、443、8080、8090;</p><p>6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态;</p><p><img src="`+c+'" alt="脚本语言支持的协议" loading="lazy"></p>',14);function v(S,b){const a=l("ExternalLinkIcon");return p(),i("div",null,[h,s("p",null,[e("1.排除法：浏览器f12查看源代码看是否是在本地进行了请求 比如：该资源地址类型为 "),s("a",u,[e("http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞"),r(a)])]),m])}const g=t(d,[["render",v],["__file","6.CSRF和SSRF.html.vue"]]);export{g as default};
