import{_ as o,V as e,W as s,Z as i}from"./framework.0d0b2430.js";const t={},p=i('<h1 id="xss" tabindex="-1"><a class="header-anchor" href="#xss" aria-hidden="true">#</a> XSS</h1><p>**定义：**XSS全称跨站点脚本攻击。跨站点脚本攻击是一种注射型攻击，攻击者在可信的网页中嵌入恶意代码，用户访问可信网页时触发XSS而被攻击。</p><p>**原理：**通过用户端注入可执行脚本，变量接受数据的时候，数据可以写成JavaScript脚本代码，服务器对用户提交的数据过滤不严，将输入的数据进行回显（输出），从而造成攻击。由于数据是JS脚本代码，是可以被浏览器识别并执行的。产生层面：输出的地方。</p><p><strong>分类：</strong></p><p>反射型（非持久型）：攻击方式多为一次性，只在用户点击时触发。</p><blockquote><p>攻击方式：攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。</p></blockquote><p>存储型（持久型）：攻击脚本将被永久的存放在目标服务器的数据库或文件中。</p><blockquote><p>攻击者在发帖或留言的过程中，将恶意脚本联通正常信息一起注入到发布内容种。随着发布内容被服务器存储下来，恶意脚本也将永远的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。存储型XSS漏洞大多出现在留言板、评论区，用户提交了包含XSS代码的留言到数据库，当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。</p></blockquote><p>DOM型（非持久性）：DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的，是一种通过DOM操作前端代码输出的时候产生的问题，不需要与后台服务器进行交互。</p><blockquote><p>DOM(Document object model)，使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。</p><p>攻击方式：用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。</p></blockquote><h3 id="cookie和session" tabindex="-1"><a class="header-anchor" href="#cookie和session" aria-hidden="true">#</a> Cookie和Session</h3><p>cookie和session都是用户凭据：可以通过凭据判断对方身份信息。</p><p>攻击成功的条件：对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址。</p><p>如果用xss平台或攻击拿到了cookie发现登录不成功，说明少了sessionID（PHPSESSID）。可以从phpinfo界面里拿到sessid，如果网站上没有phpinfo，可以自己构建phpinfo界面。</p><p>**cookie和session的区别：**cookie是存储在本地，存活时间较长，小中型网站用；session是会话，存储在服务器，存活时间较短，大型网站用。</p><h3 id="http-only" tabindex="-1"><a class="header-anchor" href="#http-only" aria-hidden="true">#</a> Http Only</h3><p>**定义：**HttpOnly是包含在http返回头Set-Cookie里面的一个附加的flag，所以它是后端服务器对cookie设置的一个附加的属性。通过JS脚本将无法读取到cookie信息，这样能有效防止xss攻击。</p><p><strong>绕过：</strong></p><p>进入后台只有两种办法：获取合法cookie和通过账号密码登录。</p><p>浏览器未保存账号密码：需要xss产生登录地址，利用表单劫持</p><p>浏览器保存账号密码：产生在后台的xss，存储型xss。如留言等，浏览器读取账号密码。</p><h3 id="防御" tabindex="-1"><a class="header-anchor" href="#防御" aria-hidden="true">#</a> 防御</h3><ol><li>从输入到输出都需要过滤和转义。检查用户输入的数据中是否包含一些特殊字符，如”&lt; &gt; 、“等</li></ol><p>发现存在特殊字符，将这些特殊字符过滤或者编码；在变量输出到HTML页面时，可以使用编码或转义。</p><ol start="2"><li>HTML实体编码：字符串JS编码转换成实体HTML编码的方法（防范XSS攻击）</li><li>对cookie设置httpOnly，防止客户端通过document.cookie读取 cookie。</li><li>将不可信的值输出URL参数之前，进行URLencode。</li><li>不要使用 eval（） 函数来解析并运行不确定的数据和代码，对于json解析使用json.parse()。</li></ol><h3 id="常见waf绕过" tabindex="-1"><a class="header-anchor" href="#常见waf绕过" aria-hidden="true">#</a> 常见WAF绕过</h3><p>标签语法替换；特殊符号干扰；提交方式更改；垃圾数据溢出；加解密算法；结合其他漏洞绕过。</p>',27),a=[p];function n(c,S){return e(),s("div",null,a)}const r=o(t,[["render",n],["__file","5.XSS.html.vue"]]);export{r as default};
